<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>慎独</title>
  
  <subtitle>Java and More</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-12-13T07:41:05.022Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Hua An</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深入理解 Java 垃圾回收机制</title>
    <link href="http://yoursite.com/2018/12/13/JVM/"/>
    <id>http://yoursite.com/2018/12/13/JVM/</id>
    <published>2018-12-13T07:37:50.000Z</published>
    <updated>2018-12-13T07:41:05.022Z</updated>
    
    <content type="html"><![CDATA[<p><strong>深入理解 Java 垃圾回收机制</strong></p><p><strong>一：垃圾回收机制的意义</strong></p><p>java  语言中一个显著的特点就是引入了java回收机制，是c++程序员最头疼的内存管理的问题迎刃而解，它使得java程序员在编写程序的时候不在考虑内存管理。由于有个垃圾回收机制，java中的额对象不在有“作用域”的概念，只有对象的引用才有“作用域”。垃圾回收可以有效的防止内存泄露，有效的使用空闲的内存；</p><p> 内存泄露：指该内存空间使用完毕后未回收，在不涉及复杂数据结构的一般情况下，java的内存泄露表现为一个内存对象的生命周期超出了程序需要它的时间长度，我们有是也将其称为“对象游离”；</p><p><strong>二：垃圾回收机制的算法</strong></p><p>java语言规范没有明确的说明JVM 使用哪种垃圾回收算法，但是任何一种垃圾回收算法一般要做两件基本事情：（1）发现无用的信息对象；（2）回收将无用对象占用的内存空间。使该空间可被程序再次使用。</p><p>1。引用计数法（Reference Counting Collector）</p><pre><code>1.1:算法分析： 引用计数算法是垃圾回收器中的早起策略，在这种方法中，堆中的每个对象实例都有一个引用计数器，点一个对象被创建时，且该对象实例分配给一个变量，该变量计数设置为1 ，当任何其他变量赋值为这个对象的引用时，计数加1 ，（a=b ，则b引用的对象实例计数器+1）但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数器减1，任何引用计数器为0 的对象实例可以当做垃圾收集。 当一个对象的实例被垃圾收集是，它引用的任何对象实例的引用计数器减1.</code></pre><p><strong>一、垃圾回收机制的意义</strong></p><p>Java语言中一个显著的特点就是引入了垃圾回收机制，使c++程序员最头疼的内存管理的问题迎刃而解，它使得Java程序员在编写程序的时候不再需要考虑内存管理。由于有个垃圾回收机制，Java中的对象不再有“作用域”的概念，只有对象的引用才有“作用域”。垃圾回收可以有效的防止内存泄露，有效的使用空闲的内存。</p><p>ps:内存泄露是指该内存空间使用完毕之后未回收，在不涉及复杂数据结构的一般情况下，Java 的内存泄露表现为一个内存对象的生命周期超出了程序需要它的时间长度，我们有时也将其称为“对象游离”。</p><p><strong>二、垃圾回收机制中的算法</strong></p><p>Java语言规范没有明确地说明JVM使用哪种垃圾回收算法，但是任何一种垃圾回收算法一般要做2件基本的事情：（1）发现无用信息对象；（2）回收被无用对象占用的内存空间，使该空间可被程序再次使用。</p><p><strong>1.引用计数法(Reference Counting Collector)</strong></p><p>1.1算法分析</p><p>引用计数是垃圾收集器中的早期策略。在这种方法中，堆中每个对象实例都有一个引用计数。当一个对象被创建时，且将该对象实例分配给一个变量，该变量计数设置为1。当任何其它变量被赋值为这个对象的引用时，计数加1（a = b,则b引用的对象实例的计数器+1），但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数器减1。任何引用计数器为0的对象实例可以被当作垃圾收集。当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器减1。</p><p>1.2优缺点</p><p>优点：</p><p>引用计数收集器可以很快的执行，交织在程序运行中。对程序需要不被长时间打断的实时环境比较有利。</p><p>缺点：</p><p>无法检测出循环引用。如父对象有一个对子对象的引用，子对象反过来引用父对象。这样，他们的引用计数永远不可能为0.</p><p>1.3引用计数算法无法解决循环引用问题，例如：</p><table><thead><tr><th>123456789101112</th><th>public class Main {    public static void main(String[] args) {        MyObject object1 = new MyObject();        MyObject object2 = new MyObject();                  object1.object = object2;        object2.object = object1;                  object1 = null;        object2 = null;    }}</th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>最后面两句将object1和object2赋值为null，也就是说object1和object2指向的对象已经不可能再被访问，但是由于它们互相引用对方，导致它们的引用计数器都不为0，那么垃圾收集器就永远不会回收它们。</p><p><strong>2.tracing算法(Tracing Collector) 或 标记-清除算法(mark and sweep)</strong></p><p>2.1根搜索算法</p><p><img src="file:///C:\Users\hj\AppData\Local\Temp\ksohtml\wpsD2A.tmp.png" alt="img"> </p><p>根搜索算法是从离散数学中的图论引入的，程序把所有的引用关系看作一张图，从一个节点GC ROOT开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点。</p><p>java中可作为GC Root的对象有</p><p>1.虚拟机栈中引用的对象（本地变量表）</p><p>2.方法区中静态属性引用的对象</p><ol start="3"><li>方法区中常量引用的对象</li></ol><p>4.本地方法栈中引用的对象（Native对象）</p><p><strong>2.2tracing算法的示意图</strong></p><p><img src="file:///C:\Users\hj\AppData\Local\Temp\ksohtml\wpsD5A.tmp.png" alt="img"> </p><p><strong>2.3标记-清除算法分析</strong></p><p>标记-清除算法采用从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收，如上图所示。标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片。</p><p><strong>3.compacting算法 或 标记-整理算法</strong></p><p><img src="file:///C:\Users\hj\AppData\Local\Temp\ksohtml\wpsD5B.tmp.png" alt="img"> </p><p>标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时不同，在回收不存活的对象占用的空间后，会将所有的存活对象往左端空闲空间移动，并更新对应的指针。标记-整理算法是在标记-清除算法的基础上，又进行了对象的移动，因此成本更高，但是却解决了内存碎片的问题。在基于Compacting算法的收集器的实现中，一般增加句柄和句柄表。</p><p><strong>4.copying算法(Compacting Collector)</strong></p><p><img src="file:///C:\Users\hj\AppData\Local\Temp\ksohtml\wpsD6C.tmp.png" alt="img"> </p><p>该算法的提出是为了克服句柄的开销和解决堆碎片的垃圾回收。它开始时把堆分成 一个对象 面和多个空闲面， 程序从对象面为对象分配空间，当对象满了，基于copying算法的垃圾 收集就从根集中扫描活动对象，并将每个 活动对象复制到空闲面(使得活动对象所占的内存之间没有空闲洞)，这样空闲面变成了对象面，原来的对象面变成了空闲面，程序会在新的对象面中分配内存。一种典型的基于coping算法的垃圾回收是stop-and-copy算法，它将堆分成对象面和空闲区域面，在对象面与空闲区域面的切换过程中，程序暂停执行。</p><p><strong>5.generation算法(Generational Collector)</strong></p><p><img src="file:///C:\Users\hj\AppData\Local\Temp\ksohtml\wpsD6D.tmp.png" alt="img"> </p><p>分代的垃圾回收策略，是基于这样一个事实：<strong>不同的对象的生命周期是不一样的</strong>。因此，不同生命周期的对象可以采取不同的回收算法，以便提高回收效率。</p><p><strong>年轻代（Young Generation）</strong></p><p>1.所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。</p><p>2.新生代内存按照8:1:1的比例分为一个eden区和两个survivor(survivor0,survivor1)区。一个Eden区，两个 Survivor区(一般而言)。大部分对象在Eden区中生成。回收时先将eden区存活对象复制到一个survivor0区，然后清空eden区，当这个survivor0区也存放满了时，则将eden区和survivor0区存活对象复制到另一个survivor1区，然后清空eden和这个survivor0区，此时survivor0区是空的，然后将survivor0区和survivor1区交换，即保持survivor1区为空， 如此往复。</p><p>3.当survivor1区不足以存放 eden和survivor0的存活对象时，就将存活对象直接存放到老年代。若是老年代也满了就会触发一次Full GC，也就是新生代、老年代都进行回收</p><p>4.新生代发生的GC也叫做Minor GC，MinorGC发生频率比较高(不一定等Eden区满了才触发)</p><p><strong>年老代（Old Generation）</strong></p><p>1.在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。</p><p>2.内存比新生代也大很多(大概比例是1:2)，当老年代内存满时触发Major GC即Full GC，Full GC发生频率比较低，老年代对象存活时间比较长，存活率标记高。</p><p><strong>持久代（Permanent Generation）</strong></p><p>用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate 等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。</p><p><strong>三.GC（垃圾收集器）<em>**</em></strong></p><p>新生代收集器使用的收集器：Serial、PraNew、Parallel Scavenge</p><p>老年代收集器使用的收集器：Serial Old、Parallel Old、CMS</p><p><img src="file:///C:\Users\hj\AppData\Local\Temp\ksohtml\wpsD6E.tmp.png" alt="img"> </p><p><strong>Serial收集器（复制算法)</strong></p><p>新生代单线程收集器，标记和清理都是单线程，优点是简单高效。</p><p><strong>Serial Old收集器(标记-整理算法)</strong></p><p>老年代单线程收集器，Serial收集器的老年代版本。</p><p><strong>ParNew收集器(停止-复制算法)　</strong></p><p>新生代收集器，可以认为是Serial收集器的多线程版本,在多核CPU环境下有着比Serial更好的表现。</p><p><strong>Parallel Scavenge收集器(停止-复制算法)</strong></p><p>并行收集器，追求高吞吐量，高效利用CPU。吞吐量一般为99%， 吞吐量= 用户线程时间/(用户线程时间+GC线程时间)。适合后台应用等对交互相应要求不高的场景。</p><p><strong>Parallel Old收集器(停止-复制算法)</strong></p><p>Parallel Scavenge收集器的老年代版本，并行收集器，吞吐量优先</p><p><strong>CMS(Concurrent Mark Sweep)收集器（标记-清理算法）</strong></p><p>高并发、低停顿，追求最短GC回收停顿时间，cpu占用比较高，响应时间快，停顿时间短，多核cpu 追求高响应时间的选择</p><p><strong>四、GC的执行机制</strong></p><p>由于对象进行了分代处理，因此垃圾回收区域、时间也不一样。GC有两种类型：Scavenge GC和Full GC。</p><p><strong>Scavenge GC</strong></p><p>一般情况下，当新对象生成，并且在Eden申请空间失败时，就会触发Scavenge GC，对Eden区域进行GC，清除非存活对象，并且把尚且存活的对象移动到Survivor区。然后整理Survivor的两个区。这种方式的GC是对年轻代的Eden区进行，不会影响到年老代。因为大部分对象都是从Eden区开始的，同时Eden区不会分配的很大，所以Eden区的GC会频繁进行。因而，一般在这里需要使用速度快、效率高的算法，使Eden去能尽快空闲出来。</p><p><strong>Full GC</strong></p><p>对整个堆进行整理，包括Young、Tenured和Perm。Full GC因为需要对整个堆进行回收，所以比Scavenge GC要慢，因此应该尽可能减少Full GC的次数。在对JVM调优的过程中，很大一部分工作就是对于FullGC的调节。有如下原因可能导致Full GC：</p><p>1.年老代（Tenured）被写满</p><p>2.持久代（Perm）被写满</p><p>3.System.gc()被显示调用</p><p>4.上一次GC之后Heap的各域分配策略动态变化</p><p><strong>五、Java有了GC同样会出现内存泄露问题<em>**</em></strong></p><p>1.静态集合类像HashMap、Vector等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，所有的对象Object也不能被释放，因为他们也将一直被Vector等应用着。</p><table><thead><tr><th>1234567</th><th>Static Vector v = new Vector(); for (int i = 1; i&lt;100; i++) {     Object o = new Object();     v.add(o);     o = null; }</th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>在这个例子中，代码栈中存在Vector 对象的引用 v 和 Object 对象的引用 o 。在 For 循环中，我们不断的生成新的对象，然后将其添加到 Vector 对象中，之后将 o 引用置空。问题是当 o 引用被置空后，如果发生 GC，我们创建的 Object 对象是否能够被 GC 回收呢？答案是否定的。因为， GC 在跟踪代码栈中的引用时，会发现 v 引用，而继续往下跟踪，就会发现 v 引用指向的内存空间中又存在指向 Object 对象的引用。也就是说尽管o 引用已经被置空，但是 Object 对象仍然存在其他的引用，是可以被访问到的，所以 GC 无法将其释放掉。如果在此循环之后， Object 对象对程序已经没有任何作用，那么我们就认为此 Java 程序发生了内存泄漏。</p><p>2.各种连接，数据库连接，网络连接，IO连接等没有显示调用close关闭，不被GC回收导致内存泄露。</p><p>3.监听器的使用，在释放对象的同时没有相应删除监听器的时候也可能导致内存泄露</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;深入理解 Java 垃圾回收机制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一：垃圾回收机制的意义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;java  语言中一个显著的特点就是引入了java回收机制，是c++程序员最头疼的内存管理的问题迎刃而解，它使得java
      
    
    </summary>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>数据库SQL优化大总结之 百万级数据库优化方案</title>
    <link href="http://yoursite.com/2018/12/11/SQL/"/>
    <id>http://yoursite.com/2018/12/11/SQL/</id>
    <published>2018-12-11T07:56:34.000Z</published>
    <updated>2018-12-12T12:51:46.061Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库SQL优化大总结之-百万级数据库优化方案"><a href="#数据库SQL优化大总结之-百万级数据库优化方案" class="headerlink" title="数据库SQL优化大总结之 百万级数据库优化方案"></a>数据库SQL优化大总结之 百万级数据库优化方案</h2><blockquote><p>网上关于SQL优化的教程很多，但是比较杂乱。近日有空整理了一下，写出来跟大家分享一下，其中有错误和不足的地方，还请大家纠正补充。<br>这篇文章我花费了大量的时间查找资料、修改、排版，希望大家阅读之后，感觉好的话推荐给更多的人，让更多的人看到、纠正以及补充。</p></blockquote><p>1.对查询进行优化，要尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。<br>2.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：<br><code>select id from t where num is null</code><br>最好不要给数据库留NULL，尽可能的使用 NOT NULL填充数据库.<br>备注、描述、评论之类的可以设置为 NULL，其他的，最好不要使用NULL。<br>不要以为 NULL 不需要空间，比如：char(100) 型，在字段建立时，空间就固定了， 不管是否插入值（NULL也包含在内），都是占用 100个字符的空间的，如果是varchar这样的变长字段， null 不占用空间。<br>可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：<br><code>select id from t where num = 0</code><br>3.应尽量避免在 where 子句中使用 != 或 &lt;&gt; 操作符，否则将引擎放弃使用索引而进行全表扫描。<br>4.应尽量避免在 where 子句中使用 or 来连接条件，如果一个字段有索引，一个字段没有索引，将导致引擎放弃使用索引而进行全表扫描，如：<br><code>select id from t where num=10 or Name = &#39;admin&#39;</code><br>可以这样查询：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">union</span> all</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">Name</span> = <span class="string">'admin'</span></span><br></pre></td></tr></table></figure></p><p>5.in 和 not in 也要慎用，否则会导致全表扫描，如：<br><code>select id from t where num in(1,2,3)</code><br>对于连续的数值，能用 between 就不要用 in 了：<br><code>select id from t where num between 1 and 3</code><br>很多时候用 exists 代替 in 是一个好的选择：<br><code>select num from a where num in(select num from b)</code><br>用下面的语句替换：<br><code>select num from a where exists(select 1 from b where num=a.num)</code><br>6.下面的查询也将导致全表扫描：<br><code>select id from t where name like ‘%abc%’</code><br>若要提高效率，可以考虑全文检索。<br>7.如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：<br><code>select id from t where num = @num</code><br>可以改为强制查询使用索引：<br><code>select id from t with(index(索引名)) where num = @num</code><br>应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：<br><code>select id from t where num/2 = 100</code><br>应改为:<br><code>select id from t where num = 100*2</code><br>9.应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">substring</span>(<span class="keyword">name</span>,<span class="number">1</span>,<span class="number">3</span>) = ’abc’       -–<span class="keyword">name</span>以abc开头的<span class="keyword">id</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">datediff</span>(<span class="keyword">day</span>,createdate,’<span class="number">2005</span><span class="number">-11</span><span class="number">-30</span>′) = <span class="number">0</span>    -–‘<span class="number">2005</span><span class="number">-11</span><span class="number">-30</span>’    <span class="comment">--生成的id</span></span><br></pre></td></tr></table></figure></p><p>应改为:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'abc%'</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> createdate &gt;= <span class="string">'2005-11-30'</span> <span class="keyword">and</span> createdate &lt; <span class="string">'2005-12-1'</span></span><br></pre></td></tr></table></figure></p><p>10.不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。<br>11.在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。<br>12.不要写一些没有意义的查询，如需要生成一个空表结构：<br><code>select col1,col2 into #t from t where 1=0</code><br>这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样：<br><code>create table #t(…)</code><br>13.Update 语句，如果只更改1、2个字段，不要Update全部字段，否则频繁调用会引起明显的性能消耗，同时带来大量日志。<br>14.对于多张大数据量（这里几百条就算大了）的表JOIN，要先分页再JOIN，否则逻辑读会很高，性能很差。<br>15<code>.select count(*) from table；</code>这样不带任何条件的count会引起全表扫描，并且没有任何业务意义，是一定要杜绝的。<br>16.索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有 必要。<br>17.应尽可能的避免更新 clustered 索引数据列，因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。<br>18.尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连 接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。<br>19.尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。<br>20.任何地方都不要使用 <code>select * from t</code> ，用具体的字段列表代替“ * ”，不要返回用不到的任何字段。<br>21.尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。22. 避免频繁创建和删除临时表，以减少系统表资源的消耗。临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件， 最好使用导出表。<br>23.在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。<br>24.如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。<br>25.尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。<br>26.使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。<br>27.与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时 间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。<br>28.在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF 。无需在执行存储过程和触发器的每个语句后向客户端发送 DONE_IN_PROC 消息。<br>29.尽量避免大事务操作，提高系统并发能力。<br>30.尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。<br>实际案例分析：拆分大的 DELETE 或INSERT 语句，批量提交SQL语句<br>如果你需要在一个在线的网站上去执行一个大的 DELETE 或 INSERT 查询，你需要非常小心，要避免你的操作让你的整个网站停止相应。因为这两个操作是会锁表的，表一锁住了，别的操作都进不来了。<br>Apache 会有很多的子进程或线程。所以，其工作起来相当有效率，而我们的服务器也不希望有太多的子进程，线程和数据库链接，这是极大的占服务器资源的事情，尤其是内存。<br>如果你把你的表锁上一段时间，比如30秒钟，那么对于一个有很高访问量的站点来说，这30秒所积累的访问进程/线程，数据库链接，打开的文件数，可能不仅仅会让你的WEB服务崩溃，还可能会让你的整台服务器马上挂了。<br>所以，如果你有一个大的处理，你一定把其拆分，使用 LIMIT oracle(rownum),sqlserver(top)条件是一个好的方法。下面是一个mysql示例：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">while(1)&#123;</span><br><span class="line"> //每次只做1000条</span><br><span class="line"> mysql_query(“<span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">logs</span> <span class="keyword">where</span> log_date &lt;= ’<span class="number">2012</span><span class="number">-11</span><span class="number">-01</span>’ <span class="keyword">limit</span> <span class="number">1000</span>”);</span><br><span class="line"> if(mysql_affected_rows() == 0)&#123;</span><br><span class="line"> //删除完成，退出！</span><br><span class="line"> break；</span><br><span class="line">&#125;</span><br><span class="line">//每次暂停一段时间，释放表让其他进程/线程访问。</span><br><span class="line">usleep(50000)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>好了，到这里就写完了。我知道还有很多没有写到的，还请大家补充。后面有空会介绍一些SQL优化工具给大家。让我们一起学习，一起进步吧！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数据库SQL优化大总结之-百万级数据库优化方案&quot;&gt;&lt;a href=&quot;#数据库SQL优化大总结之-百万级数据库优化方案&quot; class=&quot;headerlink&quot; title=&quot;数据库SQL优化大总结之 百万级数据库优化方案&quot;&gt;&lt;/a&gt;数据库SQL优化大总结之 百万级数
      
    
    </summary>
    
    
      <category term="SQL优化" scheme="http://yoursite.com/tags/SQL%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
</feed>
